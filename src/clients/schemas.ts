import { z } from 'zod';

type ContextSchema = {
  [k: string]: 'string' | 'number' | 'boolean' | 'date' | ContextSchema;
};

const contextSchemaSchema: z.ZodSchema<ContextSchema> = z.lazy(() =>
  z
    .record(
      z.union([
        contextSchemaSchema,
        z
          .enum(['string', 'number', 'boolean', 'date'])
          .describe('a primitive data type: string, number, boolean, or date'),
      ]),
    )
    .describe(
      'a schema structure, mapping keys to a primitive type (string, number, boolean, or date) or recursively to a nested schema',
    ),
);

const promptObjectSchema = z
  .object({
    template: z.string().describe('a mustache template string'),
    contextSchema: contextSchemaSchema.describe(
      'an arbitrarily nested map of variable names from the mustache template to primitive types (string, number, or boolean)',
    ),
  })
  .describe(
    'a complete prompt template with a template string and a context schema',
  );

const RuleReviewSchema = z.object({
  isRuleCompliant: z.boolean(),
  relatedRules: z.object({
    compliant: z.array(
      z.object({
        rule: z.string(),
        reason: z.string(),
        confidenceScore: z.number(),
      }),
    ),
    violations: z.array(
      z.object({
        rule: z.string(),
        reason: z.string(),
        confidenceScore: z.number(),
        violationInstances: z.array(
          z.object({
            file: z.string(),
            lineNumbersInDiff: z.array(z.string()),
            violatingCodeSnippet: z.string(),
            explanationOfViolation: z.string(),
          }),
        ),
      }),
    ),
    requiresHumanReview: z.array(
      z.object({
        rule: z.string(),
        reason: z.string(),
        confidenceScore: z.number(),
        humanReviewRequired: z.object({
          pointsOfAmbiguity: z.array(z.string()),
          questionsForManualReviewer: z.array(z.string()),
        }),
      }),
    ),
  }),
  unrelatedRules: z.array(z.string()).optional(),
});

const FollowedProjectSchema = z.object({
  name: z.string(),
  slug: z.string(),
  vcs_type: z.string(),
});

const PipelineSchema = z.object({
  id: z.string(),
  project_slug: z.string(),
  number: z.number(),
});

const WorkflowSchema = z.object({
  id: z.string(),
  name: z.string(),
  status: z.string().nullable(),
  created_at: z.string(),
  stopped_at: z.string().nullable().optional(),
  pipeline_number: z.number(),
  project_slug: z.string(),
  pipeline_id: z.string(),
});

const RerunWorkflowSchema = z.object({
  workflow_id: z.string(),
});

const JobSchema = z.object({
  job_number: z.number().optional(),
  id: z.string(),
});

export const Artifact = z.object({
  path: z.string(),
  url: z.string(),
  node_index: z.number(),
  size: z.number(),
});

export type Artifact = z.infer<typeof Artifact>;

const JobDetailsSchema = z.object({
  build_num: z.number(),
  steps: z.array(
    z.object({
      name: z.string(),
      actions: z.array(
        z.object({
          index: z.number(),
          step: z.number(),
          failed: z.boolean().nullable(),
        }),
      ),
    }),
  ),
  workflows: z.object({
    job_name: z.string(),
  }),
});

const FlakyTestSchema = z.object({
  flaky_tests: z.array(
    z.object({
      job_number: z.number(),
      test_name: z.string(),
    }),
  ),
  total_flaky_tests: z.number(),
});

const TestSchema = z.object({
  message: z.string(),
  run_time: z.union([z.string(), z.number()]),
  file: z.string().optional(),
  result: z.string(),
  name: z.string(),
  classname: z.string(),
});

const PaginatedTestResponseSchema = z.object({
  items: z.array(TestSchema),
  next_page_token: z.string().nullable(),
});

const ConfigValidateSchema = z.object({
  valid: z.boolean(),
  errors: z
    .array(
      z.object({
        message: z.string(),
      }),
    )
    .nullable(),
  'output-yaml': z.string(),
  'source-yaml': z.string(),
});

const RunPipelineResponseSchema = z.object({
  number: z.number(),
});

const RollbackProjectRequestSchema = z.object({
  component_name: z.string().describe('The component name'),
  current_version: z.string().describe('The current version'),
  environment_name: z.string().describe('The environment name'),
  namespace: z.string().describe('The namespace').optional(),
  parameters: z.record(z.any()).describe('The extra parameters for the rollback pipeline').optional(),
  reason: z.string().describe('The reason for the rollback').optional(),
  target_version: z.string().describe('The target version'),
});

const RollbackProjectResponseSchema = z.object({
  id: z.string().describe('The ID of the rollback pipeline or the command created to handle the rollback'),
  rollback_type: z.string().describe('The type of the rollback'),
});

const DeploySettingsResponseSchema = z.object({
  create_autogenerated_releases: z.boolean().optional().describe('Whether to create autogenerated releases'),
  rollback_pipeline_definition_id: z.string().optional().describe('The rollback pipeline definition ID, if configured for this project'),
}).passthrough(); // Allow additional properties we might not know about

const DeployComponentsResponseSchema = z.object({
  items: z.array(z.object({
    id: z.string(),
    project_id: z.string(),
    name: z.string(),
    release_count: z.number(),
    labels: z.array(z.string()),
    created_at: z.string(),
    updated_at: z.string(),
  })),
  next_page_token: z.string().nullable(),
});

const DeployComponentVersionsResponseSchema = z.object({
  items: z.array(z.object({
    name: z.string(),
    namespace: z.string(),
    environment_id: z.string(),
    is_live: z.boolean(),
    pipeline_id: z.string(),
    workflow_id: z.string(),
    job_id: z.string(),
    job_number: z.number(),
    last_deployed_at: z.string(),
  })),
  next_page_token: z.string().nullable(),
});

export const DeployEnvironmentResponseSchema = z.object({
  items: z.array(z.object({
  id: z.string(),
  name: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
  labels: z.array(z.string()),
  })),
  next_page_token: z.string().nullable(),
});

const ProjectSchema = z.object({
  id: z.string(),
  organization_id: z.string(),
});

const PipelineDefinitionSchema = z.object({
  id: z.string(),
  name: z.string(),
});

const PipelineDefinitionsResponseSchema = z.object({
  items: z.array(PipelineDefinitionSchema),
});

export const PipelineDefinition = PipelineDefinitionSchema;
export type PipelineDefinition = z.infer<typeof PipelineDefinitionSchema>;

export const PipelineDefinitionsResponse = PipelineDefinitionsResponseSchema;
export type PipelineDefinitionsResponse = z.infer<
  typeof PipelineDefinitionsResponseSchema
>;

export const Test = TestSchema;
export type Test = z.infer<typeof TestSchema>;

export const PaginatedTestResponse = PaginatedTestResponseSchema;
export type PaginatedTestResponse = z.infer<typeof PaginatedTestResponseSchema>;

export const FlakyTest = FlakyTestSchema;
export type FlakyTest = z.infer<typeof FlakyTestSchema>;

export const ConfigValidate = ConfigValidateSchema;
export type ConfigValidate = z.infer<typeof ConfigValidateSchema>;

// Export the schemas and inferred types with the same names as the original types
export const Pipeline = PipelineSchema;
export type Pipeline = z.infer<typeof PipelineSchema>;

export const RunPipelineResponse = RunPipelineResponseSchema;
export type RunPipelineResponse = z.infer<typeof RunPipelineResponseSchema>;

export const Project = ProjectSchema;
export type Project = z.infer<typeof ProjectSchema>;

export const PaginatedPipelineResponseSchema = z.object({
  items: z.array(Pipeline),
  next_page_token: z.string().nullable(),
});
export type PaginatedPipelineResponse = z.infer<
  typeof PaginatedPipelineResponseSchema
>;

export const Workflow = WorkflowSchema;
export type Workflow = z.infer<typeof WorkflowSchema>;

export const Job = JobSchema;
export type Job = z.infer<typeof JobSchema>;

export const JobDetails = JobDetailsSchema;
export type JobDetails = z.infer<typeof JobDetailsSchema>;

export const FollowedProject = FollowedProjectSchema;
export type FollowedProject = z.infer<typeof FollowedProjectSchema>;

export const PromptObject = promptObjectSchema;
export type PromptObject = z.infer<typeof PromptObject>;

export const RerunWorkflow = RerunWorkflowSchema;
export type RerunWorkflow = z.infer<typeof RerunWorkflowSchema>;

export const RuleReview = RuleReviewSchema;
export type RuleReview = z.infer<typeof RuleReviewSchema>;

export const RollbackProjectRequest = RollbackProjectRequestSchema;
export type RollbackProjectRequest = z.infer<typeof RollbackProjectRequestSchema>;

export const RollbackProjectResponse = RollbackProjectResponseSchema;
export type RollbackProjectResponse = z.infer<typeof RollbackProjectResponseSchema>;

export const DeploySettingsResponse = DeploySettingsResponseSchema;
export type DeploySettingsResponse = z.infer<typeof DeploySettingsResponseSchema>;

export const DeployComponentsResponse = DeployComponentsResponseSchema;
export type DeployComponentsResponse = z.infer<typeof DeployComponentsResponseSchema>;

export const DeployEnvironmentResponse = DeployEnvironmentResponseSchema;
export type DeployEnvironmentResponse = z.infer<typeof DeployEnvironmentResponseSchema>;

export const DeployComponentVersionsResponse = DeployComponentVersionsResponseSchema;
export type DeployComponentVersionsResponse = z.infer<typeof DeployComponentVersionsResponseSchema>;

const UsageExportJobStartSchema = z.object({
  usage_export_job_id: z.string().uuid(),
});

const UsageExportJobStatusSchema = z.object({
  state: z.string(),
  download_urls: z.array(z.string().url()).optional().nullable(),
});

export const UsageExportJobStart = UsageExportJobStartSchema;
export type UsageExportJobStart = z.infer<typeof UsageExportJobStartSchema>;

export const UsageExportJobStatus = UsageExportJobStatusSchema;
export type UsageExportJobStatus = z.infer<typeof UsageExportJobStatusSchema>;
